<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.85">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 

<title> Introduction to Systems Architecture</title><body bgcolor="#ffffff">
 
<h1 align="center">Introduction to Systems Architecture </h1>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Introduction</h2>

<div class="p"><!----></div>

<center><img src="Figs/howold.png" alt="Figs/howold.png" />

<div class="p"><!----></div>
</center>
<ul>
<li> From previous subjects, you've seen programs in Java like the one
above.
<div class="p"><!----></div>
</li>

<li> You have been told that this is translated, via bytecode, into machine
instructions which then run on the computer.
<div class="p"><!----></div>
</li>

<li> This raises several questions, like:

<div class="p"><!----></div>

<ul>
<li> Exactly how does the computer hardware, and the CPU in particular,
run machine instructions?
<div class="p"><!----></div>
</li>

<li> How are files stored and organised on the hard drive?
<div class="p"><!----></div>
</li>

<li> How can my machine be running many applications at the same time,
even though I only have one CPU?
<div class="p"><!----></div>
</li>

<li> Exactly what is an operating system, and why do I need one?
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> These are the sort of questions that we are going to answer in this
subject.
<div class="p"><!----></div>
</li>

<li> We are going to look at what happens when your program runs, when
it asks the system to do <tt>System.out.print()</tt> etc.
<div class="p"><!----></div>
</li>

<li> We will be looking at the hardware/software interface: how does the
hardware run software, and how does software tell the hardware what
to do.
<div class="p"><!----></div>
</li>

<li> We will also place a focus on the security aspect of the combined
hardware/software system: what features of each permit or restrict
functionality, to whom, and how the hardware/software work in tandem
to improve the overall security of the combined system.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;A Computer System: Layers of Functionality</h2>

<ul>
<li> We can view a computer system as a set of layers, each one providing
some functionality to the layers above, and hiding the messy details
of the layer behind some <em>interface</em> or set of <em>abstractions</em>.
Here are the main ones:
<div class="p"><!----></div>
</li>
</ul>

<center>
<img src="Figs/basicsysarch.gif" alt="Figs/basicsysarch.gif" />

<div class="p"><!----></div>
</center>
<ul>
<li> The system can run three basic types of programs:

<div class="p"><!----></div>

<ul>
<li> User programs are the ones that users write themselves, such as the
Java program above. Unfortunately, this is becoming rarer and rarer.
<div class="p"><!----></div>
</li>

<li> Application programs are those which provide a certain application
or functionality to the user, such as web browsers, document editors,
spreadsheets, e-mail readers etc.
<div class="p"><!----></div>
</li>

<li> Systems programs are those programs which come with the operating
system and which allow the user to do low-level, diagnostic or configuration
operations, e.g. set up networking, check the ink levels in the printer,
defragment the files on a hard disk etc.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Below the programs are a set of libraries. Each library contains a
set of commonly-used functions which are made available to the programs
so that programmers don't have to keep rewriting them. For example,
the <tt>sqrt()</tt> maths function is in the library, as are functions
to draw windows and widgets on the screen, to do DNS queries etc.
<div class="p"><!----></div>
</li>

<li> All of the above operate in <b>user mode</b>. In this mode, direct
access to the hardware is prohibited. Programs running in user mode
are given an <b>address space</b>, visible only to themselves, which
contains enough memory for them to do their job.
<div class="p"><!----></div>
</li>

<li> Below the user mode is the operating system, which runs in <b>kernel
mode</b>. It has full access to the hardware, as well as access to all
the free memory and the memory in use by the running programs.
<div class="p"><!----></div>
</li>

<li> The operating system has three main tasks to perform.

<div class="p"><!----></div>

<ol type="1">
<li> The operating system must shield the details of the hardware from
the application programs, and thus from the user.
<div class="p"><!----></div>
</li>

<li> The operating system has to <i>substitute</i> a set of abstract
services to the application programs, to replace the physical hardware
services. When applications use these abstract services, the operations
must be translated into real hardware operations.
<div class="p"><!----></div>
</li>

<li> Finally, the resources in a computer (CPU, memory, disk space etc.)
are limited. The operating system must act as a resource manager,
optimising the use of the resources, and protecting them against misuse
and abuse. When a system provides multiuser or multitasking capabilities,
resources must be allocated fairly and equitably amongst a number
of competing requests.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> So far, all of these levels are software levels. In general, the programs,
libraries and the operating system are translated to machine instructions.
Programs run their instructions, and as required they can request
the libraries and the operating system to perform some tasks on their
behalf.
<div class="p"><!----></div>
</li>

<li> Below the software is the hardware, whose job is to run the software
instructions in the programs, libraries and the operating system.
The main components are:

<div class="p"><!----></div>

<ul>
<li> the CPU which actually performs the instructions. However, it only
has immediate access to a small number of very fast memory locations
known as <em>registers</em>. To store large amounts of data which a
program is running, we need
<div class="p"><!----></div>
</li>

<li> main memory, which has large amounts of much slower data storage.
This holds the machine instructions of the programs which are running,
and the data they are currently using.
<div class="p"><!----></div>
</li>

<li> The CPU and main memory are connected to the other, peripheral devices
devices on the system such as I/O devices like keyboards and screens,
network interfaces, hard disks etc. Typically, the main memory is
about 100x slower than the CPU, and the peripheral devices are 1000x
or more slower than the CPU.
<div class="p"><!----></div>
</li>

<li> All of the hardware is interconnected by a set of <b>busses</b>
which move data between the hardware devices, as well as the machine
instructions and other control signals.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Interfaces and Abstractions</h3>

<ul>
<li> As mentioned, each layer hides its own messy details and instead provides
an interface or a set of abstractions to the layer above. Let's quickly
look at each of the interfaces and abstractions.
<div class="p"><!----></div>
</li>

<li> Internally, the operation of the CPU, and the intercommunication between
it, the memory and the peripheral devices is nasty, complicated, and
of no consequence to the programmer who just wants to run her programs.
<div class="p"><!----></div>
</li>

<li> The CPU hides its operation, and replaces it by a set of <b>machine
instructions</b> which the programmer can use to tell the CPU what to
do. In general, all CPUs provide instructions to:

<div class="p"><!----></div>

<ul>
<li> do basic maths: add, subtract, multiply, divide.
<div class="p"><!----></div>
</li>

<li> make comparisons between data items: ==, !=, &#62;, &#62;=, &lt;, &lt;=
<div class="p"><!----></div>
</li>

<li> deal with data items of different types and sizes: characters, integers,
floating-point numbers.
<div class="p"><!----></div>
</li>

<li> divert the CPU to new instructions depending on the result of a comparison:
branches, jumps, function calls.
<div class="p"><!----></div>
</li>

<li> deal with the differing levels of privilege (user mode and kernel
mode), and to control the main memory and the peripheral devices.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Each CPU has a different set of instructions, and we refer to each
one as the CPU's <a href="http://en.wikipedia.org/wiki/Instruction_set_architecture">instruction set architecture</a>
or <b>ISA</b>.
<div class="p"><!----></div>
</li>

<li> We will be looking at the internal operation of the CPU, as well as
the design of instruction sets and the ISA of some example CPUs.
<div class="p"><!----></div>
</li>

<li> The next interface is that provided by the operating system, which
controls the hardware for security and peformance reasons, and attempts
to allocate resources equitably to a number of competing programs.
<div class="p"><!----></div>
</li>

<li> The operating system shields the programs from the hardware, and substitutes
a more abstract set of services.
<div class="p"><!----></div>
</li>

<li> Examples of these abstract services are:

<div class="p"><!----></div>

<ul>
<li> the <em>process</em>, which is a program in execution surrounded by
an environment which only it has access to.
<div class="p"><!----></div>
</li>

<li> <em>virtual memory</em>, which allows a process to appear to have more
memory than is physically on the system.
<div class="p"><!----></div>
</li>

<li> <em>files</em> and a <em>filesystem</em>, a tree-structured collection
of documents, whereas the disk hardware does not provide this.
<div class="p"><!----></div>
</li>

<li> <em>windows</em> and their management, again a concept which the graphics
hardware does not provide.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> These operating system services come in the form of a set of <b>system
calls</b>. A program can make a system call, and ask the operating system
(in kernel mode) to perform some action that the program (in user
mode) cannot do itself, e.g. create a new file, or get another 100
M of memory, or print a document to the printer.
<div class="p"><!----></div>
</li>

<li> Above the operating systems are the libraries. Each library usually
groups several related functions together. We call the set of functions
that a library provides its <b>Application Programming Interface</b>,
or <b>API</b>.

<div class="p"><!----></div>

<ul>
<li> Side note: from now on, as you use things, look out for abstractions
and interfaces.
<div class="p"><!----></div>
</li>

<li> When you sit in the driver's seat of a car, what is the interface?
Is it standardised, or are there a few different interfaces?
<div class="p"><!----></div>
</li>

<li> When you use your mobile phone, what is the interface?
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The Basics of Computer Architecture</h2>

<ul>
<li> In the first half of the subject, we are going to look at how the
CPU is designed and how it interacts with the other hardware components
of the system: main memory, disk drives, input/output devices like
the keyboard, network card etc.
<div class="p"><!----></div>
</li>

<li> All of this is known as <em>computer architecture</em>.
<div class="p"><!----></div>
</li>

<li> We are going to stay just above the electronics side of the area (computer
engineering) and concentrate on the logical side of computer architecture.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;von Neumann Design and the Instruction Cycle</h3>

<ul>
<li> Nearly all modern computers are designed using the <b><a href="http://en.wikipedia.org/wiki/Von_neumann_architecture">von Neumann architecture</a></b>,
also known as the <b>stored-program architecture</b>.

<div class="p"><!----></div>

<center><img src="Figs/vonNeumann.gif" alt="Figs/vonNeumann.gif" />

<div class="p"><!----></div>
</center>
<div class="p"><!----></div>
</li>

<li> In this architecture, there is a processing unit (which we call the
<b>Central Processing Unit</b> or <b>CPU</b>) which performs the
basic computing operations (add, subtract, etc.).
<div class="p"><!----></div>
</li>

<li> This unit obtains its data from an external memory unit, and writes
back the results to the memory unit.
<div class="p"><!----></div>
</li>

<li> The memory unit is also used to hold the program instructions, which
control the processing unit and tell it how to manipulate the data.
The idea of keeping both the data and the instructions in the memory
unit is the essence of the stored-program architecture.
<div class="p"><!----></div>
</li>

<li> Why is this important? Early computers like ENIAC were programmed
by manually rewiring parts of the computer, so as to change the hard-wired
program instructions.
<div class="p"><!----></div>
</li>
</ul>

<center>
<img src="Figs/eniac.jpg" alt="Figs/eniac.jpg" />

<div class="p"><!----></div>
</center>
<center>(from Wikipedia)

<div class="p"><!----></div>
</center>
<ul>
<li> John von Neumann, among others, realised that the program's instructions
could be stored in memory.
<div class="p"><!----></div>
</li>

<li> The computer could then fetch the next instruction from memory, decode
the meaning of the instruction, and then perform the instruction.
<div class="p"><!----></div>
</li>

<li> If data was required from memory to perform the instruction, this
could also be fetched. When the instruction was complete, any result
of the instruction could be written back out to memory.
<div class="p"><!----></div>
</li>

<li> Thus, to perform an instruction on a von Neumann machine, we need
to perform an <b>instruction cycle</b>:

<div class="p"><!----></div>

<ul>
<li> fetch the next instruction
<div class="p"><!----></div>
</li>

<li> decode the instruction
<div class="p"><!----></div>
</li>

<li> execute the instruction
<div class="p"><!----></div>
</li>

<li> save the results of the instruction
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> This also implies that the computer is keeping track of where in memory
the next instruction is located.
<div class="p"><!----></div>
</li>

<li> Internally, the CPU keeps a <b>program counter</b>, or <b>PC</b>,
which holds the address of the next instruction to fetch.
<div class="p"><!----></div>
</li>

<li> The "counter" part is a bit of a misnomer; it's probably better
to call it the "next instruction address".
<div class="p"><!----></div>
</li>

<li> In the normal flow of execution, instructions are consecutive, so
the CPU can increment the PC to be the address of the next instruction.
<div class="p"><!----></div>
</li>

<li> However, when the CPU makes decisions or loops, the next instruction
is not immediately after the previous one, so the PC is not simply
incremented; its value jumps. We will see how this is done later.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;The Structure of Memory</h3>

<ul>
<li> For the purposes of this subject, we can view memory as an array of
cells; each cell holds one byte (i.e. 8 bits).
<div class="p"><!----></div>
</li>

<li> Each cell has a unique numeric address, starting at 0 and going up
to some large number:

<div class="p"><!----></div>

<center>
<table border="1">
<tr><td align="center"><b>0</b> </td><td align="center"><b>1</b> </td><td align="center"><b>2</b> </td><td align="center"><b>3</b> </td><td align="center"><b>4</b> </td><td align="center"><b>5</b> </td><td align="center"><b>...</b></td></tr>
<tr><td></td></tr>
<tr><td align="center">01010010 </td><td align="center">11111110 </td><td align="center">10111000 </td><td align="center">00010010 </td><td align="center">01011001 </td><td align="center">11001100 </td><td align="center">...</td></tr>
</table>


<div class="p"><!----></div>
</center>
<div class="p"><!----></div>
</li>

<li> The CPU and memory are connected via three busses:
<div class="p"><!----></div>
</li>
</ul>

<center>
<img src="Figs/memcpuconnect.gif" alt="Figs/memcpuconnect.gif" />

<div class="p"><!----></div>
</center>
<ul>
<li> The CPU uses the <b>address bus</b> to inform the memory of the
specific cell it is interested in.

<div class="p"><!----></div>

<ul>
<li> if the address bus is 32 bits wide, then 2<sup>32</sup> memory cells can
be addressed. i.e. 4 Gbytes.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> The CPU uses the <b>control bus</b> to inform the memory what operation
to perform: read the cell, (over)write the cell.

<div class="p"><!----></div>

<ul>
<li> the memory can use the control bus to tell the CPU if the action succeeded
or failed. For example, in a computer with only 2G of 4 Gbytes installed,
accesses to memory locations about the 2G mark will fail.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Finally, the <b>data bus</b> conveys the data (or a program instruction)
between the CPU and memory.

<div class="p"><!----></div>

<ul>
<li> on a write, data flows from the CPU to the memory, overwriting the
contents of the cell.
<div class="p"><!----></div>
</li>

<li> on a read, data flows from a cell in memory to the CPU.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;The Data Bus Size and the von Neumann Bottleneck</h3>

<ul>
<li> The size of the data bus defines the natural size of data on a CPU.
<div class="p"><!----></div>
</li>

<li> When a computer is called a "32-bit" computer, this means that
the data bus is 32 bits in size, and reads &amp; writes to/from memory
are normally done in groups of 32 bits

<div class="p"><!----></div>

<ul>
<li> this immediately implies that a 32-bit fetch from address X cannot
just involve the cell at X, because each cell is 1-byte in size
<div class="p"><!----></div>
</li>

<li> a 32-bit fetch will fetch 32 bits of data from consecutive cells starting
at address X, i.e. X, X+1, X+2 and X+3.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> We use the term "<b>word</b>" to mean the natural size of
data on a computer. A 32-bit computer uses 32-bit words; a 64-bit
computer uses 64-bit words.
<div class="p"><!----></div>
</li>

<li> One of the main drawbacks of the von Neumann architcture is that the
data bus presents a bottleneck: this is the only path through which
the CPU can obtain its instructions and data.
<div class="p"><!----></div>
</li>

<li> In practice, this is a real problem. It would be too expensive to
create large amounts of memory which runs as the same speed as the
CPU, so the speed of memory and the data bus is a significant bottleneck
to the design of fast computers.
<div class="p"><!----></div>
</li>

<li> One solution is to employ a hierarchy of memory of different amounts
and speeds.
<div class="p"><!----></div>
</li>

<li> This works because most computer programs exhibit <b><a href="http://en.wikipedia.org/wiki/Locality_of_reference">locality of reference</a></b>:
over a short period of time, most data and instruction accesses come
from the same set of memory locations. Therfore, we can cache the
values in these memory locations in the higher-speed memory units.
<div class="p"><!----></div>
</li>
</ul>

<center>
<img src="Figs/mem_hierarchy.gif" alt="Figs/mem_hierarchy.gif" />

<div class="p"><!----></div>
</center>
<ul>
<li> The CPU performs its operations on a small set of <b>registers</b>,
each of which holds one word of data. Typically, a CPU has between
8 and 64 registers only.
<div class="p"><!----></div>
</li>

<li> To manipulate more data than can be kept in the registers, the CPU
needs to read from/write to main memory.
<div class="p"><!----></div>
</li>

<li> Using the locality of reference, the most frequent data/instruction
values are kept in the Level 1 cache, which is typically 2-3x as slow
as the registers, and is around 64K-256K bytes in size. The L1 cache
usually resides on the CPU.
<div class="p"><!----></div>
</li>

<li> If the L1 cache is too small, a fast data bus connects the CPU out
to the L2 cache. This is typically 10-20x slower than the CPU registers,
and around 1M-16M bytes in size.
<div class="p"><!----></div>
</li>

<li> And when the running program's locality of reference exceeds that
of the two caches, the CPU has to go all the way out to main memory
to access data &amp; instructions. Main memory is typically 20-200x slower
than the CPU registers.
<div class="p"><!----></div>
</li>

<li> The operation of memory caches is complex and fraught with problems.
We won't be exploring cache operation in this subject. Likewise, the
improving the performance of the CPU with a pipeline will not be explored
in this subject.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;The Difference between Address and Data Bus Sizes</h3>

<ul>
<li> Note that the address bus and the data bus are separate and unrelated.
<div class="p"><!----></div>
</li>

<li> The size of the address bus determines how much memory can be addressed
by a CPU: a 32-bit address bus can only address 4 Gbytes of RAM.
<div class="p"><!----></div>
</li>

<li> The size of the data bus determines the natural size of data accesses
on the CPU.
<div class="p"><!----></div>
</li>

<li> Unfortunately, many common CPUs like the Intel Pentium have been designed
with both busses the same size. This has given rise to the misconception
that a 32-bit CPU (i.e. one with a 32-bit data bus) can only access
4 Gbytes of memory, which is false.
<div class="p"><!----></div>
</li>

<li> It is quite possible to build a CPU with different bus sizes, and
there are many, many examples of this.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Components of the CPU </h3>

<ul>
<li> Let's now turn our attention to the components inside the CPU, where
instructions are executed.
<div class="p"><!----></div>
</li>
</ul>

<center>
<img src="Figs/basiccpuarch.gif" alt="Figs/basiccpuarch.gif" />

<div class="p"><!----></div>
</center>
<center>(adapted from Britton)

<div class="p"><!----></div>
</center>
<ul>
<li> The above diagram shows the main components of the CPU, and the arrowed
lines show the main flows of data and instructions

<div class="p"><!----></div>

<ul>
<li> Note that <em>Data in</em>, <em>Data out</em> and <em>Instruction out</em>
represent data flows across the data bus, and
<div class="p"><!----></div>
</li>

<li> the flows out from the Program Counter and the ALU into the triangle
labelled <em>Address</em> use the address bus.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> The <b>Program Counter</b> (PC) holds the address of the next instruction.
During the fetch phase of the instruction cycle, the PC's value is
sent across the address bus, and the next instruction travels back
across the data bus into the CPU.
<div class="p"><!----></div>
</li>

<li> The incoming instruction is stored in the <b>Instruction Register</b>.
This is decoded to determine:

<div class="p"><!----></div>

<ul>
<li> what <em>operation</em> to perform.
<div class="p"><!----></div>
</li>

<li> what <em>operands</em> does the operation act on: typically, one or
more registers are chosen.
<div class="p"><!----></div>
</li>

<li> however, on some architectures, a <em>literal value</em> may be encoded
in part of the instruction.
<div class="p"><!----></div>
</li>

<li> and on some architectures, the instruction might require further fetches
of data from main memory.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Parts of the instruction influence the <b>control logic</b> in the
CPU (not shown in the diagram). The control logic is the set of signals
which control the other components in the CPU, such as the ALU and
the multiplexors.
<div class="p"><!----></div>
</li>

<li> Once the instruction is decoded, the execution of the instruction
can start.
<div class="p"><!----></div>
</li>

<li> The <b>Arithmetic Logic Unit</b> (<b>ALU</b>), informed via the
control logic of the operation, performs that operation on the operands
and outputs the result.

<div class="p"><!----></div>

<ul>
<li> The inputs to the ALU are chosen by <b>multiplexors</b>, which receive
a number of inputs, and based on a number of control lines, select
only one of the inputs to propagate to the multiplexor's output.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> When the ALU calculates its output, this needs to be stored somewhere.
This could be:

<div class="p"><!----></div>

<ul>
<li> back into a register in the CPU, or
<div class="p"><!----></div>
</li>

<li> stored in the Program Counter, e.g. when a jump is performed to skip
past some instructions. Otherwise, the PC will just increment to the
next value, or
<div class="p"><!----></div>
</li>

<li> the ALU's output can be written back to main memory.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> That ends one instruction cycle. The PC has a new value, and so the
next instruction cycle can begin, with the CPU fetching a new instruction
from memory.
<div class="p"><!----></div>
</li>

<li> Finally, note the multiplexor to the left of the main memory block.
This is used to choose either:

<div class="p"><!----></div>

<ul>
<li> the address of the PC, so that a new instruction is fetched from memory,
or
<div class="p"><!----></div>
</li>

<li> the address of a data item, so that it can be fetched from memory,
or overwritten with a new value.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Similarly, the multiplexor to the left of the registers chooses which
register will be overwritten with data from memory, or the result
of the ALU's operation.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.85.<br />On  2 May 2011, 10:25.</small>
</body></html>
